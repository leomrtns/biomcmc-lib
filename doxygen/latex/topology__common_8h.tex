\hypertarget{topology__common_8h}{}\subsection{topology\+\_\+common.\+h File Reference}
\label{topology__common_8h}\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}


General-\/purpose topology structures created from nexus\+\_\+tree\+\_\+struct (and low-\/level functions)  


{\ttfamily \#include \char`\"{}bipartition.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}distance\+\_\+matrix.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}empirical\+\_\+frequency.\+h\char`\"{}}\newline
Include dependency graph for topology\+\_\+common.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{topology__common_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{topology__common_8h__dep__incl}
\end{center}
\end{figure}
\subsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structtopol__node__struct}{topol\+\_\+node\+\_\+struct}
\begin{DoxyCompactList}\small\item\em Information of a node (binary tree). \end{DoxyCompactList}\item 
struct \hyperlink{structtopology__struct}{topology\+\_\+struct}
\begin{DoxyCompactList}\small\item\em Binary unrooted topology (rooted at leaf with ID zero) \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{topology__common_8h_a996cc8f62d29656325d956b30b1d7cdf}\label{topology__common_8h_a996cc8f62d29656325d956b30b1d7cdf}} 
typedef struct \hyperlink{structtopol__node__struct}{topol\+\_\+node\+\_\+struct} $\ast$ {\bfseries topol\+\_\+node}
\item 
\mbox{\Hypertarget{topology__common_8h_a84f4179678a44fe3dd321d10fc4d58a0}\label{topology__common_8h_a84f4179678a44fe3dd321d10fc4d58a0}} 
typedef struct \hyperlink{structtopology__struct}{topology\+\_\+struct} $\ast$ {\bfseries topology}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{topology__common_8h_ac8291febbe6145a25c3f21931ddc4f12}\label{topology__common_8h_ac8291febbe6145a25c3f21931ddc4f12}} 
\hyperlink{structtopology__struct}{topology} \hyperlink{topology__common_8h_ac8291febbe6145a25c3f21931ddc4f12}{new\+\_\+topology} (int nleaves)
\begin{DoxyCompactList}\small\item\em Allocate space for new \hyperlink{structtopology__struct}{topology\+\_\+struct}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_afef9dfca253f6e961e349f289b10c7d8}\label{topology__common_8h_afef9dfca253f6e961e349f289b10c7d8}} 
void \hyperlink{topology__common_8h_afef9dfca253f6e961e349f289b10c7d8}{topology\+\_\+malloc\+\_\+blength} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em Allocate vector for branch lengths (3 vectors\+: mean, min and max values observed in topol\+\_\+space collection) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a43cdaa9b821e3e8059be8097576921d5}\label{topology__common_8h_a43cdaa9b821e3e8059be8097576921d5}} 
void \hyperlink{topology__common_8h_a43cdaa9b821e3e8059be8097576921d5}{del\+\_\+topology} (\hyperlink{structtopology__struct}{topology} topol)
\begin{DoxyCompactList}\small\item\em Free space allocated by \hyperlink{structtopology__struct}{topology\+\_\+struct}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a1044e831883af50f68ed2819ca81272b}\label{topology__common_8h_a1044e831883af50f68ed2819ca81272b}} 
void {\bfseries debug\+\_\+topol} (\hyperlink{structtopology__struct}{topology} tree)
\item 
void \hyperlink{topology__common_8h_a83d1514270e2f2575eaa94f454b425d5}{copy\+\_\+topology\+\_\+from\+\_\+topology} (\hyperlink{structtopology__struct}{topology} to\+\_\+tree, \hyperlink{structtopology__struct}{topology} from\+\_\+tree)
\begin{DoxyCompactList}\small\item\em Copy information from \hyperlink{structtopology__struct}{topology\+\_\+struct}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_ad1ae251ff6844438a1891ee3ab10ad70}\label{topology__common_8h_ad1ae251ff6844438a1891ee3ab10ad70}} 
void \hyperlink{topology__common_8h_ad1ae251ff6844438a1891ee3ab10ad70}{update\+\_\+topology\+\_\+sisters} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em Update pointers to topol\+\_\+node\+\_\+struct\+::sister. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a2ff833f0afb5478b2da6c2e3591750e3}\label{topology__common_8h_a2ff833f0afb5478b2da6c2e3591750e3}} 
void \hyperlink{topology__common_8h_a2ff833f0afb5478b2da6c2e3591750e3}{update\+\_\+topology\+\_\+traversal} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em Update topol\+\_\+node\+::preorder, topol\+\_\+node\+::postorder, topol\+\_\+node\+::bipartition and order siblings by number of descendants. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a6835412616c6e3aee7a752664ab2d452}\label{topology__common_8h_a6835412616c6e3aee7a752664ab2d452}} 
\hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} \hyperlink{topology__common_8h_a6835412616c6e3aee7a752664ab2d452}{topology\+\_\+is\+\_\+equal} (\hyperlink{structtopology__struct}{topology} t1, \hyperlink{structtopology__struct}{topology} t2)
\begin{DoxyCompactList}\small\item\em Compare two topologies based on bipartitions as clades (not on branch lengths) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_abf57ef1d396f3f84fcaedda2529009fb}\label{topology__common_8h_abf57ef1d396f3f84fcaedda2529009fb}} 
\hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} \hyperlink{topology__common_8h_abf57ef1d396f3f84fcaedda2529009fb}{topology\+\_\+is\+\_\+equal\+\_\+unrooted} (\hyperlink{structtopology__struct}{topology} t1, \hyperlink{structtopology__struct}{topology} t2, \hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} use\+\_\+root\+\_\+later)
\begin{DoxyCompactList}\small\item\em Compare two topologies based on bipartitions neglecting root; boolean ask if split should be reverted to original orientation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_af11e8e50c89c3e943661968aed34fb0b}\label{topology__common_8h_af11e8e50c89c3e943661968aed34fb0b}} 
void \hyperlink{topology__common_8h_af11e8e50c89c3e943661968aed34fb0b}{reorder\+\_\+topology\+\_\+leaves} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em Reorder \hyperlink{structchar__vector__struct}{char\+\_\+vector\+\_\+struct}; leaf node ids (and bipartitions) must then follow this order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a9a1a22b2dec13f46ba3b68e83477cd12}\label{topology__common_8h_a9a1a22b2dec13f46ba3b68e83477cd12}} 
\hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} \hyperlink{topology__common_8h_a9a1a22b2dec13f46ba3b68e83477cd12}{node1\+\_\+is\+\_\+child\+\_\+of\+\_\+node2} (\hyperlink{structtopol__node__struct}{topol\+\_\+node} node1, \hyperlink{structtopol__node__struct}{topol\+\_\+node} node2)
\begin{DoxyCompactList}\small\item\em Boolean if node2 is on the path of node1 to the root. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{topology__common_8h_a6db1cb85d5a57b3a3c91fe735861204a}{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id} (const \hyperlink{structtopology__struct}{topology} tree, double $\ast$blen)
\begin{DoxyCompactList}\small\item\em Print subtree in newick format to string using leaf I\+Ds. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{topology__common_8h_aa60cb33af89c2c7b74bb218eb9468bf3}{topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name} (const \hyperlink{structtopology__struct}{topology} tree, double $\ast$blen)
\begin{DoxyCompactList}\small\item\em Print subtree in newick format to string creating names (based on leaf I\+Ds.) \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{topology__common_8h_aa728f9d79edb4799b279bd837398b75d}{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name} (const \hyperlink{structtopology__struct}{topology} tree, double $\ast$blen)
\begin{DoxyCompactList}\small\item\em Print subtree in newick format to string using leaf names. \end{DoxyCompactList}\item 
void \hyperlink{topology__common_8h_afee3da24d5b00f28be299e8231dc7789}{graphviz\+\_\+file\+\_\+topology} (F\+I\+LE $\ast$fout, char $\ast$label, const \hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em Prints subtree in dot format to file. \end{DoxyCompactList}\item 
void \hyperlink{topology__common_8h_ac0b9b2dacd758c4a9a79075fd582e824}{apply\+\_\+spr\+\_\+at\+\_\+nodes} (\hyperlink{structtopology__struct}{topology} p, \hyperlink{structtopol__node__struct}{topol\+\_\+node} prune, \hyperlink{structtopol__node__struct}{topol\+\_\+node} regraft, \hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} update\+\_\+done)
\begin{DoxyCompactList}\small\item\em Apply one subtree prune-\/and-\/regraft (S\+PR branch swapping) operation at specified nodes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a62e09c235d771e69aee2993e79e9731c}\label{topology__common_8h_a62e09c235d771e69aee2993e79e9731c}} 
void \hyperlink{topology__common_8h_a62e09c235d771e69aee2993e79e9731c}{apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+\+L\+C\+Aprune} (\hyperlink{structtopology__struct}{topology} tree, \hyperlink{structtopol__node__struct}{topol\+\_\+node} prune, \hyperlink{structtopol__node__struct}{topol\+\_\+node} regraft, \hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} update\+\_\+done)
\begin{DoxyCompactList}\small\item\em Apply one S\+PR branch swapping at specified nodes when prune subtree is above prune node. \end{DoxyCompactList}\item 
void \hyperlink{topology__common_8h_aa3d4404bbf462e60510a35810d617d3f}{apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune} (\hyperlink{structtopology__struct}{topology} tree, \hyperlink{structtopol__node__struct}{topol\+\_\+node} prune, \hyperlink{structtopol__node__struct}{topol\+\_\+node} regraft, \hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} update\+\_\+done)
\begin{DoxyCompactList}\small\item\em Apply one S\+PR branch swapping at specified nodes when subtree to be pruned is below prune node. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_ae95c8cdd4571f36a098d29b2a1d54f3d}\label{topology__common_8h_ae95c8cdd4571f36a098d29b2a1d54f3d}} 
void \hyperlink{topology__common_8h_ae95c8cdd4571f36a098d29b2a1d54f3d}{topology\+\_\+undo\+\_\+random\+\_\+move} (\hyperlink{structtopology__struct}{topology} tree, \hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool} update\+\_\+done)
\begin{DoxyCompactList}\small\item\em revert last S\+PR branch swapping \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_acd897c1f66dc20e16d13606f3c7d2684}\label{topology__common_8h_acd897c1f66dc20e16d13606f3c7d2684}} 
void \hyperlink{topology__common_8h_acd897c1f66dc20e16d13606f3c7d2684}{clear\+\_\+topology\+\_\+flags} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em reset all d\+\_\+done and u\+\_\+done booleans to \char`\"{}true\char`\"{} (when rejecting a new state in M\+C\+MC) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a02592320bb8d6c0d6c587e3fe67a290e}\label{topology__common_8h_a02592320bb8d6c0d6c587e3fe67a290e}} 
void \hyperlink{topology__common_8h_a02592320bb8d6c0d6c587e3fe67a290e}{raise\+\_\+topology\+\_\+flags} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em reset all d\+\_\+done and u\+\_\+done booleans to \char`\"{}false\char`\"{} (when updating a model parameter with M\+TM) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_ae10e4d2ac03cd340e2bdbc955deeb98d}\label{topology__common_8h_ae10e4d2ac03cd340e2bdbc955deeb98d}} 
void \hyperlink{topology__common_8h_ae10e4d2ac03cd340e2bdbc955deeb98d}{topology\+\_\+reset\+\_\+random\+\_\+move} (\hyperlink{structtopology__struct}{topology} tree)
\begin{DoxyCompactList}\small\item\em revert last S\+PR branch swapping and clear flags (reject last proposal, in M\+C\+MC) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a1dc404c846a472241f1d8bee9ff69196}\label{topology__common_8h_a1dc404c846a472241f1d8bee9ff69196}} 
int \hyperlink{topology__common_8h_a1dc404c846a472241f1d8bee9ff69196}{copy\+\_\+topology\+\_\+to\+\_\+intvector\+\_\+by\+\_\+postorder} (\hyperlink{structtopology__struct}{topology} tree, int $\ast$ivec)
\begin{DoxyCompactList}\small\item\em store ID of each node\textquotesingle{}s parent (in postorder) into vector, returning number of stored nodes \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a877c063091488c9440864b537074b2a2}\label{topology__common_8h_a877c063091488c9440864b537074b2a2}} 
int \hyperlink{topology__common_8h_a877c063091488c9440864b537074b2a2}{copy\+\_\+intvector\+\_\+to\+\_\+topology\+\_\+by\+\_\+postorder} (\hyperlink{structtopology__struct}{topology} tree, int $\ast$ivec)
\begin{DoxyCompactList}\small\item\em restore topological structure based on postordered ID vector, returning number of restored nodes \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a35b2182e8fe4a91acdbe04f4a3b6a9ef}\label{topology__common_8h_a35b2182e8fe4a91acdbe04f4a3b6a9ef}} 
void \hyperlink{topology__common_8h_a35b2182e8fe4a91acdbe04f4a3b6a9ef}{copy\+\_\+topology\+\_\+to\+\_\+intvector\+\_\+by\+\_\+id} (\hyperlink{structtopology__struct}{topology} tree, int $\ast$ivec)
\begin{DoxyCompactList}\small\item\em store ID of each node\textquotesingle{}s parent into vector \end{DoxyCompactList}\item 
\mbox{\Hypertarget{topology__common_8h_a2e10f61f4c12949770e11fd17cee1144}\label{topology__common_8h_a2e10f61f4c12949770e11fd17cee1144}} 
void \hyperlink{topology__common_8h_a2e10f61f4c12949770e11fd17cee1144}{copy\+\_\+intvector\+\_\+to\+\_\+topology\+\_\+by\+\_\+id} (\hyperlink{structtopology__struct}{topology} tree, int $\ast$ivec)
\begin{DoxyCompactList}\small\item\em restore topological structure based on ID vector \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{Detailed Description}
General-\/purpose topology structures created from nexus\+\_\+tree\+\_\+struct (and low-\/level functions) 

The topology structure should actually be called \char`\"{}tree\char`\"{} since it has information about branch lengths, but these functions neglect branch lenght information. Here we have functions that create split bipartitions for edges (stored by nodes below the edge) and compare distinct topologies based on these bipartitions. We also have here the lowest-\/level function that apply an S\+PR on a topology (again, without caring about the branch length). 

\subsubsection{Function Documentation}
\mbox{\Hypertarget{topology__common_8h_a83d1514270e2f2575eaa94f454b425d5}\label{topology__common_8h_a83d1514270e2f2575eaa94f454b425d5}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!copy\+\_\+topology\+\_\+from\+\_\+topology@{copy\+\_\+topology\+\_\+from\+\_\+topology}}
\index{copy\+\_\+topology\+\_\+from\+\_\+topology@{copy\+\_\+topology\+\_\+from\+\_\+topology}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{copy\+\_\+topology\+\_\+from\+\_\+topology()}{copy\_topology\_from\_topology()}}
{\footnotesize\ttfamily void copy\+\_\+topology\+\_\+from\+\_\+topology (\begin{DoxyParamCaption}\item[{\hyperlink{structtopology__struct}{topology}}]{to\+\_\+tree,  }\item[{\hyperlink{structtopology__struct}{topology}}]{from\+\_\+tree }\end{DoxyParamCaption})}



Copy information from \hyperlink{structtopology__struct}{topology\+\_\+struct}. 

Since I\+Ds do not change, this function only needs to update topol\+\_\+node\+\_\+struct\+::up, topol\+\_\+node\+\_\+struct\+::right, and topol\+\_\+node\+\_\+struct\+::left pointers and topol\+\_\+node\+\_\+struct\+::map\+\_\+id from internal nodes; update of topol\+\_\+node\+::sister is handled by function \hyperlink{topology__common_8h_ad1ae251ff6844438a1891ee3ab10ad70}{update\+\_\+topology\+\_\+sisters()}. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em from\+\_\+tree} & original \hyperlink{structtopology__struct}{topology\+\_\+struct} \\
\hline
\mbox{\tt out}  & {\em to\+\_\+tree} & (previously allocated) copied \hyperlink{structtopology__struct}{topology\+\_\+struct} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{topology__common_8h_a6db1cb85d5a57b3a3c91fe735861204a}\label{topology__common_8h_a6db1cb85d5a57b3a3c91fe735861204a}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id@{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id}}
\index{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id@{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id()}{topology\_to\_string\_by\_id()}}
{\footnotesize\ttfamily char$\ast$ topology\+\_\+to\+\_\+string\+\_\+by\+\_\+id (\begin{DoxyParamCaption}\item[{const \hyperlink{structtopology__struct}{topology}}]{tree,  }\item[{double $\ast$}]{blen }\end{DoxyParamCaption})}



Print subtree in newick format to string using leaf I\+Ds. 

Stores in string the tree in newick format, using leaf ID numbers (in practical applications needs a T\+R\+A\+N\+S\+L\+A\+T\+I\+ON nexus block). Memory allocation is handled by this function, but needs to be freed by the calling function. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tree} & tree to be printed \\
\hline
\mbox{\tt in}  & {\em blen} & vector with branch lengths (usually tree-\/$>$blength) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to newly allocated string 
\end{DoxyReturn}
\mbox{\Hypertarget{topology__common_8h_aa60cb33af89c2c7b74bb218eb9468bf3}\label{topology__common_8h_aa60cb33af89c2c7b74bb218eb9468bf3}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name@{topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name}}
\index{topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name@{topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name()}{topology\_to\_string\_create\_name()}}
{\footnotesize\ttfamily char$\ast$ topology\+\_\+to\+\_\+string\+\_\+create\+\_\+name (\begin{DoxyParamCaption}\item[{const \hyperlink{structtopology__struct}{topology}}]{tree,  }\item[{double $\ast$}]{blen }\end{DoxyParamCaption})}



Print subtree in newick format to string creating names (based on leaf I\+Ds.) 

Stores in string the tree in newick format, using newly-\/created names based on leaf ID numbers (useful for generating random trees that must be read by other programs.) Memory allocation is handled by this function, but needs to be freed by the calling function. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tree} & tree to be printed \\
\hline
\mbox{\tt in}  & {\em blen} & vector with branch lengths (usually tree-\/$>$blength) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to newly allocated string 
\end{DoxyReturn}
\mbox{\Hypertarget{topology__common_8h_aa728f9d79edb4799b279bd837398b75d}\label{topology__common_8h_aa728f9d79edb4799b279bd837398b75d}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name@{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name}}
\index{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name@{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name()}{topology\_to\_string\_by\_name()}}
{\footnotesize\ttfamily char$\ast$ topology\+\_\+to\+\_\+string\+\_\+by\+\_\+name (\begin{DoxyParamCaption}\item[{const \hyperlink{structtopology__struct}{topology}}]{tree,  }\item[{double $\ast$}]{blen }\end{DoxyParamCaption})}



Print subtree in newick format to string using leaf names. 

Stores in string the tree in newick format, preserving sequence names if available. Memory allocation is handled by this function, but needs to be freed by the calling function. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em tree} & tree to be printed \\
\hline
\mbox{\tt in}  & {\em blen} & vector with branch lengths (usually tree-\/$>$blength) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to newly allocated string 
\end{DoxyReturn}
\mbox{\Hypertarget{topology__common_8h_afee3da24d5b00f28be299e8231dc7789}\label{topology__common_8h_afee3da24d5b00f28be299e8231dc7789}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!graphviz\+\_\+file\+\_\+topology@{graphviz\+\_\+file\+\_\+topology}}
\index{graphviz\+\_\+file\+\_\+topology@{graphviz\+\_\+file\+\_\+topology}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{graphviz\+\_\+file\+\_\+topology()}{graphviz\_file\_topology()}}
{\footnotesize\ttfamily void graphviz\+\_\+file\+\_\+topology (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{fout,  }\item[{char $\ast$}]{label,  }\item[{const \hyperlink{structtopology__struct}{topology}}]{tree }\end{DoxyParamCaption})}



Prints subtree in dot format to file. 

Prints to file the tree in dot format (undirected graph). The dot format can be used with the \href{http://www.graphviz.org/}{\tt graphviz} suite of programs, and is not restricted to trees but can also handle arbitrary graph structures. Notice that we do not make use of the graphviz library, we simply create the text file graphviz programs take as input. Unfortunately, it is not helpful to print the nexus\+\_\+tree\+\_\+struct since the program works basically with the \hyperlink{structtopology__struct}{topology\+\_\+struct}. On the other hand it is easy to change this function to make it work with \hyperlink{structtopology__struct}{topology\+\_\+struct}. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em fout} & pointer to file handler where tree is to be printed; \\
\hline
\mbox{\tt in}  & {\em label} & graph name or any other label; \\
\hline
\mbox{\tt in}  & {\em tree} & \hyperlink{structtopology__struct}{topology\+\_\+struct} to be printed; \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{topology__common_8h_ac0b9b2dacd758c4a9a79075fd582e824}\label{topology__common_8h_ac0b9b2dacd758c4a9a79075fd582e824}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!apply\+\_\+spr\+\_\+at\+\_\+nodes@{apply\+\_\+spr\+\_\+at\+\_\+nodes}}
\index{apply\+\_\+spr\+\_\+at\+\_\+nodes@{apply\+\_\+spr\+\_\+at\+\_\+nodes}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{apply\+\_\+spr\+\_\+at\+\_\+nodes()}{apply\_spr\_at\_nodes()}}
{\footnotesize\ttfamily void apply\+\_\+spr\+\_\+at\+\_\+nodes (\begin{DoxyParamCaption}\item[{\hyperlink{structtopology__struct}{topology}}]{p,  }\item[{\hyperlink{structtopol__node__struct}{topol\+\_\+node}}]{prune,  }\item[{\hyperlink{structtopol__node__struct}{topol\+\_\+node}}]{regraft,  }\item[{\hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool}}]{update\+\_\+done }\end{DoxyParamCaption})}



Apply one subtree prune-\/and-\/regraft (S\+PR branch swapping) operation at specified nodes. 

Each node is associated to one edge (the branch immediately above it), thus the location of the regraft node will impose the direction of pruning -\/ the prune edge will always detach away from subtree containing regraft. The actual S\+PR move needs to handle two cases\+: {\bfseries prune node is in the path from regraft node to the root} (prune node is least common ancestor between prune and regraft) and {\bfseries prune node is not in the path from regraft node to root} (prune and regraft nodes share a distinct common ancestor). When prune node is the root, the first case implies in rerooting. Checking against illegal moves (prune==regraft, prune==regraft-\/$>$up, etc) should be done previous to this function call. This function will call the corresponding lower-\/level one based on position of prune node. If you know the direction of pruning (rerooting, e.\+g.) you can call the other two functions directly.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em p} & topology over which to apply move \\
\hline
\mbox{\tt in}  & {\em prune} & node to be pruned (detached). Direction determined by regraft \\
\hline
\mbox{\tt in}  & {\em regraft} & node above which prune node will be reattached \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{topology__common_8h_aa3d4404bbf462e60510a35810d617d3f}\label{topology__common_8h_aa3d4404bbf462e60510a35810d617d3f}} 
\index{topology\+\_\+common.\+h@{topology\+\_\+common.\+h}!apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune@{apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune}}
\index{apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune@{apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune}!topology\+\_\+common.\+h@{topology\+\_\+common.\+h}}
\paragraph{\texorpdfstring{apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune()}{apply\_spr\_at\_nodes\_notLCAprune()}}
{\footnotesize\ttfamily void apply\+\_\+spr\+\_\+at\+\_\+nodes\+\_\+not\+L\+C\+Aprune (\begin{DoxyParamCaption}\item[{\hyperlink{structtopology__struct}{topology}}]{tree,  }\item[{\hyperlink{structtopol__node__struct}{topol\+\_\+node}}]{prune,  }\item[{\hyperlink{structtopol__node__struct}{topol\+\_\+node}}]{regraft,  }\item[{\hyperlink{lowlevel_8h_a97a80ca1602ebf2303258971a2c938e2}{bool}}]{update\+\_\+done }\end{DoxyParamCaption})}



Apply one S\+PR branch swapping at specified nodes when subtree to be pruned is below prune node. 

{\bfseries prune is not lca}\+: Detach the prune subtree and reinsert it just above the regraft node (regraft node may be root).

\begin{DoxyVerb}*  Prune: 
*
*  p.left\              /p.up.up                       p.left\                |p.up.up                  
*         \prune___p.up/                       ==>            \p_______prune  |                         
*         /            \                                      /               |                         
* p.right/              \p.up.left || p.up.right      p.right/                |p.up.left || p.up.right  
*
* \end{DoxyVerb}


\begin{DoxyVerb}*  Regraft: 
*
*  p.left\                |r.up        p.left\               /prune.up (=r.up.up)
*         \p_______prune  |      ==>          \p_______prune/ 
*         /               |                   /             \
* p.right/                |r          p.right/               \r
*
* \end{DoxyVerb}
